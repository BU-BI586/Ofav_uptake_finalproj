---
title: "Orbicella Faveolata Reuptake"
author: "Maria Ingersoll, Jamie Poirer, Susritha Kopparapu"
date: "4/29/2021"
output:
  html_document: default
---


## Introduction

## Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#### R Version
R version 4.0.3 was used for this analysis. 

#### Packages
The following packages were used to clean, analyze, and visualize data. Packages were installed with [Bioconductor](https://bioconductor.org/biocLite.R) version 3.12 or the [Cran Repository](http://cran.us.r-project.org).   
```{r, message=FALSE, warning=FALSE}
library("DESeq2")                   #Version 1.30.1
library("arrayQualityMetrics")      #Version 3.46.0
library("dplyr")                    #Version 1.0.5
library("RColorBrewer")             #Version 1.1.2
library("gplots")                   #Version 3.1.1
library("tidyverse")                #Version 1.3.0
library("pheatmap")                 #Version 1.0.12
library("vegan")                    #Version 2.5.7
library("ggplot2")                  #Version 3.3.3
library("ggrepel")                  #Version 0.9.1
```

```{r, eval=FALSE, echo=FALSE}
packageVersion("DESeq2")
packageVersion("arrayQualityMetrics")
packageVersion("dplyr")
packageVersion("RColorBrewer")
packageVersion("gplots")
packageVersion("tidyverse")
packageVersion("pheatmap")
packageVersion("vegan")
packageVersion("ggplot2")
packageVersion("ggrepel")


#packageVersion("affycoretools")
#packageVersion("genefilter")

```

## Raw Data Filtering

```{r, eval=FALSE}
setwd("/Users/mariaingersoll/Desktop/BU2020-2021/Ecol_and_Enviro_Genomics/BI586-git/Ofav_uptake_finalproj")
```

```{r, echo=FALSE}
setwd("~/BI 586/FinalProject")
```

Counts data was stored in a text file that was read in as a data frame to a variable called `countData`. Note that this data was pre-filtered for a base mean of 3. The column names are renamed based on the the strain type and replicate number for readability sake. The length of the data frame is reported and it represents the number of isoforms.
```{r}
countData <- read.table("orbfav_uptake_counts.txt")
newColNames = c("BR.A", "BR.B", "BR.C", "BR.D", "CR.A", "CR.B", "CR.C","DR.A","DR.B", "DR.C", "DR.D")
colnames(countData)=paste(newColNames)
length(countData[,1])
```

The total sum of isoform counts for each condition are displayed below in a barplot. The minimum and maximum are as reported below. 
```{r, echo=FALSE, fig.cap="**Figure 1.** All raw sequencing count values from each *Orbicella faveolata* sample demonstrating various degrees of library sizes. Green bars are *O. faveolata* hosting Symbiodiniaceae strain B01 (replicates: BR.A, BR.B, BR.C, BR.D). Red bars are *O. faveolata* hosting Symbiodiniaceae strain C (triplicates: CR.A,CR.B, CR.c). Blue bars are *O. faveolata* hosting Symbiodiniaceae strain D (replicates: DR.A, DR.B, DR.C, DR.D).", fig.width=10}
totalCounts=colSums(countData)
barplot(totalCounts, col=c("green",  "green", "green", "green", "red", "red", "red", "blue", "blue" , "blue" , "blue"), ylab="Raw Counts", xlab="Coral Hosting Symbiodiniaceae Strains")
```

```{r}
min(totalCounts)
max(totalCounts)
```

#### Remove small library size replicates

Due to the small library sizes, one replicate from the strain B, one replicate from the strain D conditions, and all replicates from O. faveolata hosting Symbiodiniaceae strain C were removed. `newCounts` is generated from the original `countData` but only selecting the samples that have larger library size and excluding the following ones as they are too small. 
```{r}
newCounts = countData %>% 
  dplyr::select(-BR.D, -CR.A, -CR.B, -CR.C, -DR.B)
```

The total sum of isoform counts for each condition are displayed below in a barplot. The minimum and maximum are as reported below. 
```{r, echo=FALSE, fig.cap="**Figure 2.** Selected raw sequencing count values from each *Orbicella faveolata* sample demonstrating various degrees of library sizes. Green bars are *O. faveolata* hosting Symbiodiniaceae strain B01 (triplicates: BR.A, BR.B, BR.C). Blue bars are *O. faveolata* hosting Symbiodiniaceae strain D (triplicates: DR.A, DR.C, DR.D). One replicate from the strain B condition, one replicate from the strain D condition, and all replicates from *O. faveolata* hosting Symbiodiniaceae strain C were removed prior to this analysis due to small library sizes."}
totalCounts=colSums(newCounts)
barplot(totalCounts, col=c("green", "green", "green", "blue" , "blue" , "blue"), ylab="Raw Counts", xlab="Coral Hosting Symbiodiniaceae Strains")
```

```{r}
min(totalCounts)
max(totalCounts)
```

*Note: In the above barplot, we see that despite the previous filtering, there are still conditions that have large library sizes (BR.C, DR.A, and DR.C) compared to other conditions that have very low library sizes (BR.A, BR.B, annd DR.B). This inconsistency in library size is the reason why the following rarefaction was performed.* 

#### Rarefy large sample size replicates

Because the difference between the minimum and maximum library size was so large, the data was rarefied and high counts were cut down to 100,000. To use the `rrarefy` function from the `vegan` package, the `newCounts` data frame variable had to be transposed with the `t` function. This transposed newCounts called `t_newCounts` data frame was supplied to `rrarefy` with a subsample size of 100,000. The new rarified counts are called `rare` and can be transposed again to provide the rarified counts used to generate the following bar plot. 

The rarefaction steps were only run once and the new counts were saved to a file. 
```{r, warning=FALSE, eval=FALSE}
t_newCounts = t(newCounts)
rare = rrarefy(t_newCounts, 100000)
unt_newCounts = t(rare)
write.table(unt_newCounts, file="rare_orbfav_uptake_counts.txt", quote=F, sep="\t")
```

The rarefaction counts are read in from the file. This is because every time `rrarfey` is run it randomly rarefies the replicates with counts greater than 100,000. This way the same counts are used for all further analysis. 
```{r}
unt_newCounts = read.table(file="rare_orbfav_uptake_counts.txt", sep="\t")
```

The total sum of isoform counts for each condition are displayed below in a barplot. The minimum and maximum are as reported below. 
```{r, echo=FALSE, fig.cap="**Figure 3.** *Orbicella faveolata* samples with raw sequencing count values greater than 100,000 were rarefied to a maximum of 100,000 total counts. Green bars are *O. faveolata* hosting Symbiodiniaceae strain B01 (triplicates: BR.A, BR.B, BR.C). Blue bars are *O. faveolata* hosting Symbiodiniaceae strain D (triplicates: DR.A, DR.C, DR.D). The samples that were rarefied were replicates BR.C, DR.A, and DR.D, while all other replicates remain as original."}
rare_totalCounts=colSums(unt_newCounts)
barplot(rare_totalCounts, col=c("green", "green", "green", "blue" , "blue" , "blue"), ylab="Raw Counts", xlab="Coral Hosting Symbiodiniaceae Strains")
```

```{r}
min(rare_totalCounts)
max(rare_totalCounts)
```

*NOTE: All following analysis will be performed with the rarefied data and it must be kept in mind for conclusions drawn about the differential expression of genes between coral hosting strain B and coral hosting strain D.*

## Outlier Analysis

For outlier analysis, we first create a character vector `treat` holding the names of the strains of Symbiodiniaceae that each coral sample is hosting. The vector is converted to a dataframe and is renamed `colData` for further use. 
```{r}
treat=c( "B", "B", "B", "D", "D", "D")
g=data.frame(treat)
colData<- g
```

`DESeqDataSetFromMatrix` was run on the `unt_newCounts` which represents the rarefied counts of the selected samples. The column data is set to the strain type and the design to the treatment vector so that it may dictate how the counts for each gene depend on the variables in colData. The `DESeq` step was run on the results of the prior step.
```{r results="hide", message=FALSE, warning=FALSE, eval=TRUE}
dds<-DESeqDataSetFromMatrix(countData=unt_newCounts, colData=colData, design=~treat)
dds<-DESeq(dds)
```

The `vst` function is the variance-stabilizing transformation which models the mean-variance relationship of replicates. The assay of `dds` generates a table with the mean-variance of each of the isoform treatments. The `as.data.frame(colData(rl)))` generates a table with the columns and a sizeFactor value that is converted into the formal `AnnotatedDataFrame` class. Both values are passed are used to create an `ExpressionSet` object which is used to generate the quality metrics with `arrayQualityMetrics` using the treat variable as the intgroup.

```{r, eval=FALSE}
vsd.ge=assay(vst(dds))
rl=vst(dds)
e=ExpressionSet(assay(rl), AnnotatedDataFrame(as.data.frame(colData(rl))))
v = setwd("/Users/mariaingersoll/Desktop/BU2020-2021/Ecol_and_Enviro_Genomics/BI586-git/Ofav_uptake_finalproj")
arrayQualityMetrics(e,outdir=v,intgroup=c("treat"),force=T)
```
*NOTE: The array quality metrics showed that there were no outliers by the three detection methods: by distances between arrays, by boxplots, and by MA plots. Below is the heatmap of sample distance between arrays.*


`results` extracts the results table from the DESeq analysis and the `DESeqDataSet` is used to generate the dispersion plot.
```{r, warning=FALSE, message=FALSE, eval=TRUE}
head(dds)
res<- results(dds)
```

```{r, echo=FALSE, fig.cap="**Figure 4.** Scatter plot of dispersion estimates per gene (on the y-axis) versus the mean of normalized counts (on the x-axis) of isoforms identified in the treatment samples of *Orbicella faveolata*. Gene-wise dispersion estimates are in black, fitted estimates are in red, and final estimates are in blue as indicated by the legend.", eval=TRUE}
plotDispEsts(dds, main="Dispersion plot Uptake")
```

R log transformation is used on the data `dds` as a data normalization method. The rlog data provides a better transformation when size factors vary across samples by transforming to a log2 scale to minimize difference between samples for rows with small counts. This r log tranformation will be important for making heatmaps.
```{r, eval=TRUE}
rld <- rlogTransformation(dds, blind=TRUE)
```

The rlog data `rld` can be converted to a matrix like object with `assay` that is then given to the `hist` function to generate a histogram of the r-log transformations. Since the rlog values can be positive or negative, the histogram shows the spread of those positive and negative values for all the samples. 
```{r, echo=FALSE, fig.cap="**Figure 5.** A histogram of the binned r log transformations frequency of *Orbicella faveolata* data where the regularized log (r log) is the original count data on a log2 scale.", eval=TRUE}
hist(assay(rld))
```


The matrix like object of the r log data `rld` is transposed and the `dist` function is performed on it to calculate the distance matrix using the specified distance measure to compute the distance between the rows. This is then stored in the `sampleDists` variable. 
```{r results="hide", message=FALSE, eval=TRUE}
sampleDists <- as.matrix(dist(t(assay(rld))))
```

The `sampleDists` matrix is used to generate a sample distance heatmap of relatednness based on the count distance or difference between samples as seen below.
```{r, echo=FALSE, fig.cap="**Figure 6.** Sample distance heatmap where BR.C is clustering more with D.", eval=TRUE}
heatmap.2(as.matrix(sampleDists), key=F, trace="none",
          col=colorpanel(100, "black", "white"),
          margin=c(10, 10))
```

The `results` function is applied to the `dds` data using a contrast by treat where B serves as the control since it is listed as the second term. The results are stored in a variable called `resBD`. We isolate the column of the data set for the p-adjusted value, and below is a report of how many of the isoforms have a p-adjusted value less than 0.1. Additionally, a summary of the `resBD` is generated as well to analyze the count differences between B and D. 
```{r, eval=TRUE}
resBD <- results(dds, contrast=c("treat","D","B"))
table(resBD$padj<0.1)
summary(resBD)
```

In the rarefied data, with an adjusted p-value of <0.1, 4 genes were significantly upregulated, and 26 were significantly downregulated in coral hosting strain D compared to coral hosting strain B. 

```{r, echo=FALSE, fig.cap="**Figure 7.** *Orbicella faveolata* hosting Symbiodiniaceae strain B01 vs *O.faveolata* hosting Symbiodiniaceae strain D scatter plot of log fold changes (on the y-axis) versus the mean of normalized counts (on the x-axis) of the isoforms identified in the samples. The non significant data points are in gray, and significant data points are represented in blue. A positive log fold change indicates that D is upregulated compared to B01, and a negative log fold change indicates that D is downregulared compared to the baseline of B01.", eval=TRUE}
plotMA(resBD, main="O.faveolata hosting strain B01 vs O.faveolata hosting strain D")
```

A table of the log fold change values between coral hosting strain B and coral hosting strain D is generated. The file contains the log fold change, the p value, and the adjusted p value. 
```{r, eval=FALSE}
write.table(resBD, file="rare_BD_DE.txt", quote=F, sep="\t")
```

## P-values and R-log data

A new table `valBD` is generated from the p-value and adjusted p-value from the original `resBD` table. The column names are appropriately set and the number of isoforms are confirmed to be the same as the original dataset, no data was lost. 
```{r, eval=TRUE}
valBD=cbind(resBD$pvalue, resBD$padj)
colnames(valBD)=c("pval.BD", "padj.BD")
length(valBD[,1])
```


A table of the number of complete cases where both the p-value and the adjusted p-value is present and not missing are reported. 
```{r, eval=TRUE}
table(complete.cases(valBD))
```

The `rld` is the variable that holds the results of the `rlogTransformation` on the `dds` data where blind=True. The r log data is converted to a matrix like object with `assay` and the column names which were originally the names of each replicate are now converted to just the name of the strain that each coral sample is hosting. The number of isoforms are confirmed to be the same as the original dataset, and no data was lost. 
```{r, eval=TRUE}
rld=assay(rld)
colnames(rld)=paste(colData$treat)
length(rld[,1])
```

The r log transformation data is combined with the p-value and the adjusted p-value that to generate the new table `rldpvals` with the dimensions reported below. A table of the number of complete cases where all values for each are isoform is present and not missing are reported. 
```{r, eval=TRUE}
rldpvals=cbind(rld,valBD)
dim(rldpvals)
table(complete.cases(rldpvals))
```

The `rldpvals` are stored in a csv file for future use. 
```{r, eval=FALSE}
write.csv(rldpvals, "rare_BI586_uptake_RLDandPVALS.csv", quote=F)
rldpvals <- read.csv(file="rare_BI586_uptake_RLDandPVALS.csv", row.names=1)
```

---------------------------------------------------------

- Now we will create a heatmap of sample distances based on pvalues
- Make a new variable for your csv file
Read in the 

- Make rld that a variable that just returns the first six columns with values (rownames then columns 1-6)
```{r, eval=FALSE}
rld=rldpvals[,1:6]
head(rld)
```
- dist computes and returns the distance matrix computed using the specified distance measure to compute distances between the rows of a data matrix (rld); determine the overall differences in expression between each sample based on the rlog values
- Turn the distances into a matrix
```{r,eval=FALSE}
sampleDists <- dist(t(rld))
sampleDistMatrix <- as.matrix(sampleDists)
```
- Create a vector of treatment titles for the matrix and apply them to the rows and columns
```{r, eval=FALSE}
treat=c("B", "B", "B", "D", "D", "D")
colnames(sampleDistMatrix)=paste(treat)
rownames(sampleDistMatrix)=paste(treat)
```

```{r results="hide", eval=FALSE}
heat.colors = colorRampPalette(rev(c("blue","yellow")),bias=0.3)(100)
```
- Apply your matrix of overall expression distance to a heatmap
```{r, echo=FALSE, fig.cap="Figure 7. Sample Distance Matrix between B and D.", eval=FALSE}
pheatmap(sampleDistMatrix,color = heat.colors,cex=0.9,border_color=NA,cluster_rows=T,cluster_cols=T)
```

-----------------------------------------------

## PCA Anlysis 

To perform the Principal Component Analysis (PCA) on the data will allow us to visualize overall effect of experimental covariates and batch effects. We first must transpose the data table hols the r log transformation data assay. 
```{r,eval=TRUE}
rld_t=t(rld)
```

The `prcomp` function performs a principal component analysis on the transformed r log data matrix where the variables should be shifted to be zero centered and that any data that contains NA should be omitted from the analysis. The an instance of the `prcomp` class is returned and stored in a variable called `pca`.
```{r warning=FALSE, eval=TRUE}
pca <- prcomp(rld_t,center = TRUE, na.action=na.omit)
```

`sdev` holds the standard deviations of the principal components and it can be used to calculate the proportion that each principal component corresponds to the variance. We can then round the PC1 and PC2 (which are the first and second items of the list) to one significant figure. 
```{r,eval=TRUE}
li <- pca$sdev^2 / sum(pca$sdev^2)
pc1v <- round(li[1] * 100, 1)
pc2v <- round(li[2] * 100, 1)
```


The x column of the `prcomp` object holds the value of the rotated data, and this is all stored in the variable `pca_s`.
```{r,eval=TRUE}
pca_s <- as.data.frame(pca$x)
```

Since we only care about the first two dimensions, of PC1 and PC2, only the first two rotated data values from `pca_s` are needed. New columns for samples and treatment names are added to the `pca_s` table. 
```{r,eval=TRUE}
pca_s <- pca_s[,c(1,2)]
head(pca_s)
pca_s$Samples = row.names(pca_s)
pca_s$treat=colData$treat
```

Then the PCA plot can be generated from the PC1 and PC2 levels. 
```{r, echo=FALSE, fig.cap="**Figure 8.** Principal component analysis of all samples in the subset of data where the PC1 along the x-axis has a 35.3% variance and the PC2 along the y-axis has a 31% variance. The legend shows the difference between *Orbicella faveolata* hosting Symbiodiniaceae strain B01 vs *O.faveolata* hosting Symbiodiniaceae strain D  samples. Adonis below shows that PC1 is significant with an alpha of 0.1, and this can be considered trending towards significance.", eval=TRUE}
cbPalette <- c("darkorchid4","firebrick4")
ggplot(pca_s, aes(PC1, PC2, color = treat, pch = treat)) +
  geom_point(size=3) +
  #  geom_text_repel(aes(label=Samples)) +
  scale_colour_manual(values=cbPalette)+
  theme_bw() +
  # geom_density2d(alpha=.5)+
  geom_polygon(alpha=.2)+
  xlab(paste0("PC1: ",pc1v,"% variance")) +
  ylab(paste0("PC2: ",pc2v,"% variance")) 
```

The PCA plot shows that samples of coral hosting strain B have a very high variance, however there is no overlap between the samples by treatment. 

We then perform the `adonis` function on the rotated pca data with the treatment as the formula and the `prcomp` matrix as the data. The method for this adonis is euclidean and we select to remove any data with NA. The adonis will show whether the conditions are significantly different. 
```{r, warnings=FALSE, message=FALSE, echo=FALSE, eval=TRUE}
adonis(pca$x ~ treat, data = pca_s, method='eu', na.rm = TRUE)
```

The `adonis` results show that PC1 is significant with an alpha of 0.1, and this can be considered trending towards significance where PC1 is explaining 35% of the variance between the two samples. 

## Pairwise Comparison of Coral Hosting Strain B vs Strain D
The treat column is represented as a factor with two levels being coral hosting strain D or strain B, where coral hosting strain B serve as the control. These are stored in a new column called D Then the `results` function extracts the results table of `DESeqDataSet` with the contrast set as treat, between strain D and strain B
```{r}
colData$D<-factor(colData$treat, levels=c("D","B"))
resD <- results(dds, contrast=c("treat","D","B"))
```

The results table reports the breakdown of how many genes had an adjusted p-value below 0.01, to be considered significant. The summary of the results with a contrast by treat (strain) is also displayed below. Notice that while only 4 of genes were upregulated, 26 were downregulated.

```{r}
table(resD$padj<0.01)
summary(resD)
```

The number of genes that have an adjusted p-value less than 0.05 and that do not have NA values for the adjusted p-values, are counted and reported below.

```{r}
nrow(resD[resD$padj<0.05 & !is.na(resD$padj),]) 
```

```{r, echo=FALSE, fig.cap="**Figure 9.** "}
plotMA(resD, main="B vs D", ylim=c(-2,2))
```


```{r include=FALSE}
results <- as.data.frame(resD)
```


The number of upregulated and downregulated genes (respectively) that have an adjusted p-value less than 0.1 and that do not have NA values for the adjusted p-value, are counted and reported below.
```{r}
nrow(resD[resD$padj<0.1 & resD$log2FoldChange > 0 & !is.na(resD$padj),])
nrow(resD[resD$padj<0.1 & resD$log2FoldChange < 0 & !is.na(resD$padj),])
```


A table of the results with a contrast by treat between coral hosting strain B and coral hosting strain D is generated. The file is read into a variable called `cd` that will be used to genereate the GO table later on. 
```{r,eval=TRUE}
write.table(resD, file="rare_D_2021.txt", quote=F, sep="\t")
cd <- read.table("rare_D_2021.txt")
```

## GO table for MWU

- Create a term go_input_D that has the -logpval as a neg number if the l2fc is < 0 and a pos number if the l2fc is > 0
- This term will go into the go analysis
```{r,eval=FALSE}
cd
go_input_D = cd %>%
  tibble::rownames_to_column(var = "iso") %>%
  mutate(mutated_p = -log(pvalue)) %>%
  mutate(mutated_p_updown = ifelse(log2FoldChange < 0, mutated_p*-1, mutated_p*1)) %>%
  na.omit() %>%
  select(iso, mutated_p_updown)
head(go_input_D)
colnames(go_input_D) <- c("gene", "pval")
head(go_input_D)
write.csv(go_input_D, file="rare_D_GO.csv", quote=F, row.names=FALSE)
```

## GO analysis 
ACTUAL DIFFERENTIAL GENE EXPRESSION ANALYSIS STARTS HERE
- This is just the preliminary GO enrichment analysis of all the genes. The way gomwu works is that it performs rankings and gives you enrichment of GO terms in the ranked list. So GO terms that show up may not actually contain only genes that are significantly differentially expressed, that gene set is just enriched

- Plotting genes within each GO category between B and D
- MF: Molecular function
- BP: Biological process
- CC: Cellular component

- Manipulated BD_DE.txt in excel following Sarah's verbal instructions and loaded it here
- BD_DE_GO has the mutated -log(p-values) \
- From the BI586_uptake file, we got log2 fold change (MLE): treat D vs B
- Reminder: this means that pos log2FC values indicate D is upregulated compared to B; The name provided in the second element (B) is the baseline

```{r,eval=FALSE}
BD_DE_GO = read.csv("rare_D_GO.csv")
```
- Creating dendrograms (more info can be found in the r file GO_MWU.R)
- First, run MF; edit the input stuff to match what you're running
- BD_DE_GO.csv has two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either significant or not).
- orb_fav_iso2go.txt is two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
- go.obo is downloaded from http://www.geneontology.org/GO.downloads.ontology.shtml
- goDivision is either MF, BP, or CC

CONTROL REPLACE ofav to isogroup in rare_D_GO.CSV so they can be linked to the go annotations file
```{r,eval=FALSE}
head(read.csv("rare_D_GO.csv"))
input="rare_D_GO.csv"
goAnnotations="orb_fav_iso2go_new.tab"
goDatabase="go.obo"
goDivision="MF"
source("gomwu.functions.R")
```

- Calculating stats. It might take ~3 min for MF and BP. Do not rerun it if you just want to replot the data with different cutoffs, go straight to gomwuPlot. If you change any of the numeric values below, delete the files that were generated in previous runs first.
- perlPath: replace with full path to perl executable if it is not in your system's PATH already
- largest: a GO category will not be considered if it contains more than this fraction of the total number of genes
- smallest: a GO category should contain at least this many genes to be considered
- clusterCutHeight: threshold for merginng similar (gene-sharing) terms. See gomwu README for details
```{r,eval=FALSE}
gomwuStats(input, goDatabase, goAnnotations, goDivision,
           perlPath="perl",
           largest=0.1,
           smallest=5,
           clusterCutHeight=0.25)
```
- NEW TRANSCRIPTOME, rarefied counts: 5 GO terms at 10% FDR

- Old transcriptome: Returned 9 GO terms at 10% FDR
- New transcriptome non-rarefied: 18 GO terms at 10% FDR
- Plot results in a dendrogram
- absValue=-log(0.05,10); genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").
- level1=0.1: FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.
- level2=0.05: FDR cutoff to print in regular (not italic) font.
- level3=0.01: FDR cutoff to print in large bold font.
- txtsize=1.5: decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect
- treeHeight=0.5: height of the hierarchical clustering tree
- colors=c("dodgerblue2","firebrick1","skyblue","lightcoral") # these are default colors, un-remark and change if needed
- Typing resultsMF gives you the data in a written format
```{r, warning=FALSE, eval=FALSE}
quartz()
resultsMF=gomwuPlot(input,goAnnotations,goDivision,
                  absValue=1,
                  level1=0.1,
                  level2=0.05,
                  level3=0.01,
                  txtsize=1.5,
                  treeHeight=0.5,
                  colors=c("dodgerblue2","firebrick1","skyblue","lightcoral")
)
resultsMF
```

- Doesn't look that pretty, but if you really want it to look nice, run the above code in base R and then you can manipulate the size of the image to your liking, or export it as a pdf and fiddle around with the size
- Red is upregulated in D and blue is downregulated in D (upregulated in B)
- The GO term we are most interested in here is Oxidoreductase, remember this for later

- Now let's run the above protocol for BP
```{r,eval=FALSE}
head(read.csv("rare_D_GO.csv"))
input="rare_D_GO.csv"
goAnnotations="orb_fav_iso2go_new.tab"
goDatabase="go.obo"
goDivision="BP"
source("gomwu.functions.R")

gomwuStats(input, goDatabase, goAnnotations, goDivision,
           perlPath="perl",
           largest=0.1,
           smallest=5,
           clusterCutHeight=0.25)
```
- NEW TRANSCRIPTOME, rarefied counts: 0 GO terms at 10% FDR
- New transcriptome non-rarefied: 10 GO Terms at 10% FDR 

```{r, warning=FALSE, eval=FALSE}
quartz()
resultsBP=gomwuPlot(input,goAnnotations,goDivision,
                  absValue=1,
                  level1=0.1,
                  level2=0.05,
                  level3=0.01,
                  txtsize=1.5,
                  treeHeight=0.5,
)
resultsBP
```

- Old transcriptome: Returned 6 GO terms at 10% FDR
- Here we are interested in the positive regulation of cell proliferation

- Now let's run it for CC
```{r,eval=FALSE}
head(read.csv("rare_D_GO.csv"))
input="rare_D_GO.csv"
goAnnotations="orb_fav_iso2go_new.tab"
goDatabase="go.obo"
goDivision="CC"
source("gomwu.functions.R")

gomwuStats(input, goDatabase, goAnnotations, goDivision,
           perlPath="perl",
           largest=0.1,
           smallest=5,
           clusterCutHeight=0.25)
```
- NEW TRANSCRIPTOME, rarefied: 5 GO terms at 10% FDR
- New transcriptome non-rarefied: 23  GO terms at 10% FDR


```{r, warning=FALSE, eval=FALSE}
quartz()
resultsCC=gomwuPlot(input,goAnnotations,goDivision,
                  absValue=1,
                  level1=0.1,
                  level2=0.05,
                  level3=0.01,
                  txtsize=1.5,
                  treeHeight=0.5,
)
resultsCC
```

- Old transcriptome: Returned 18 GO terms of interest
- Interested in the mitochondrial complexes



INVESTIGATING DIFFERENTIAL EXPRESSION OF GENES IN SPECIFIC GO CATEGORIES
- Using Dan Wuitchik's code: https://github.com/wuitchik/Divergent-thermal-challenges-elicit-convergent-stress-signatures-in-aposymbiotic-Astrangia-poculata/blob/master/Astrangia_HotCold.pdf
- Looking at "oxidoreductase, acting on a heme group of donors, oxygen as acceptor" [MF GO terms: GO:0004129;GO:0015002;GO:0016676;GO:0016675], "mitochondrial membrane part" [CC GO term: GO:0044455], and "mitochondrial part" [CC GO term: GO:0044429]

- Set up the variable iso2go which contains the ofav gene id and all of its associated GO terms


```{r, eval=FALSE}
iso2go = read.table("orb_fav_iso2go_new.tab", sep="\t")
head(iso2go)
colnames(iso2go) <- c("gene_ID", "GO.terms")
```
- Obtain the gene symbol from the gene descriptions in the file orb_fav_iso2gene.tab
- Create the variable gene which contains the gene id, the full description, and the gene symbol
```{r,eval = FALSE}
newnames = c("gene_ID", "description" )
iso2gene = read.table("orb_fav_iso2gene_new.tab", sep="\t")
colnames(iso2gene) <- newnames

gene = iso2gene %>%
       mutate(gene_symbol = gsub(".* GN=", "", description)) %>%
       mutate(gene_symbol = gsub(" .*", "", gene_symbol))
head(gene)
```
- To get the rlog foldchange values, I'm going to manipulate the BI586 uptake file (which I will save in a variable called BD_DE)
```{r,eval=FALSE}
head(read.csv("rare_BI586_uptake_RLDandPVALS.csv"))
BD_DE = read.csv("rare_BI586_uptake_RLDandPVALS.csv")

head(BD_DE)
rlog_BD = BD_DE[,1:7] %>%
  rename(gene_ID = X)
head(rlog_BD)
```
- rlog_BD just has the isoform names (called gene_ID) and the log2FC for each sample
- could have also used the tidyverse select function instead of [,1:7] here, Dan says it's better to keep the same format so using select would have been better

- Next, make a variable that contains all the genes that correspond to the GO terms of interest, first doing mitochondrial membrane
```{r, warning=FALSE, eval=FALSE}
cc = read.csv("CC_rare_D_GO.csv", sep="\t")
head(cc)
colnames(cc)[4]="gene_ID"
head(cc)
mitochondria = cc %>%
  filter(str_detect(term, "GO:0044455|GO:0044429")) %>%
  left_join(rlog_BD) %>%
  left_join(gene) %>%
  mutate(gene_symbol = make.names(gene_symbol, unique = TRUE)) %>%
  column_to_rownames(var = "gene_symbol") %>%
  dplyr::select(-name, -term, -lev, -value, -description, -gene_ID) %>%
  drop_na() %>%
  dplyr::select(sort(current_vars()))
```

```{r, eval=FALSE}
head(mitochondria)
nrow(mitochondria)
```

- 71 terms correspond to these parent GO terms for mitochondrial function
- Plot a heatmap of the differential expression of ALL the genes that correspond to mitochondrial membrane function
- Then calculate the mean and plot that
```{r,eval=FALSE}
heatmap_mit = heatmap.2(as.matrix(mitochondria), Rowv = TRUE, Colv = FALSE, scale = "row",
          dendrogram = "both",
          trace = "none",
          main = "GO Mitochondria",
          margin = c(5,15))


```

- Yellow to white correspond to upregulation and red corresponds to downregulation

- Now doing the same for oxidoreductase
- Oxidoreductase complex from CC (GO:1990204); oxidoreductase activity from MF (GO:0016491)
- To filter for multiple terms, use | (the symbol that is shift back slash) and quotes only outside all the terms
```{r,eval=FALSE}
oxidoreductase = iso2go %>%
  filter(str_detect(GO.terms, "GO:0004129|GO:0015002|GO:0016676|GO:0016675")) %>%
  left_join(rlog_BD) %>%
  left_join(gene) %>%
  mutate(gene_symbol = make.names(gene_symbol, unique = TRUE)) %>%
  column_to_rownames(var = "gene_symbol") %>%
  dplyr::select(-GO.terms, -description, -gene_ID) %>%
  drop_na() %>%
  dplyr::select(sort(current_vars()))
head(oxidoreductase)
nrow(oxidoreductase)
```
- 16 genes correspond to these four terms in rarefied data
- Plot a heatmap of the differential expression of ALL the genes that correspond to the oxidoreductase GO terms above
```{r,eval=FALSE}
heatmap_oxidoreductase = heatmap.2(as.matrix(oxidoreductase), Rowv = TRUE, Colv = TRUE, scale = "row",
                               dendrogram = "both",
                               trace = "none",
                               main = "GO Oxidoreductase",
                               margin = c(5,15))
```

- Notice that in the above heatmaps, we clustered the columns (the samples) as well as the rows. When we clustered the columns in the oxidoreductase heatmap, B.2 clusters with the Ds. This may be an affect of the count values we obtained from each sample, as B.2 was the B sample with the high count values.
- One way to mitigate this is to take the means of the rows, subtract the mean from the original value, and plot the result instead of the original value
- We'll also be filtering for only those genes that are significantly differentially expressed between recruits hosting D vs B

- Now we want to make new heatmaps of just those genes in cell prolif and oxidoreductase that are significantly differentially expressed (we will use an alpha of 0.1)

- Filter the BI586 uptake data for all genes significantly differentially expressed (alpha = 0.1 for this section, we will use the more stringent 0.05 later)
```{r,eval=FALSE}
BD_DE_10 = filter(BD_DE, pval.BD <= 0.1, preserve = TRUE)
head(BD_DE_10) 
rlog_BD_10 = BD_DE_10[,1:7] %>%
  rename(gene_ID = X)
head(rlog_BD_10)
nrow(rlog_BD_10)
```
- rlog_BD_10 has all the genes that are sig DE with alpha=0.1 and does not contain the p-val nor the adj p-val (550 genes in rarefied data)

- Now search within this list for all genes that correspond to the GO term for pos reg of cell prolif and call this new list GO_0008284_sig
```{r,eval=FALSE}
GO_mit_sig = cc %>%
  filter(str_detect(term, "GO:0044455|GO:0044429")) %>%
  left_join(rlog_BD_10) %>%
  left_join(gene) %>%
  mutate(gene_symbol = make.names(gene_symbol, unique = TRUE)) %>%
  column_to_rownames(var = "gene_symbol") %>%
  dplyr::select(-name, -term, -lev, -value, -description, -gene_ID) %>%
  drop_na() %>%
  dplyr::select(sort(current_vars()))
GO_mit_sig
nrow(GO_mit_sig)

```
- We have 10 genes, plot them in a heatmap but this time use the calculated difference from the mean
```{r,eval=FALSE}
GO_mit_means_sig = apply(GO_mit_sig, 1, mean)
explc_mit = GO_mit_sig-GO_mit_means_sig
head(explc_mit)
col0=colorRampPalette(rev(c("chocolate1","#FEE090","grey10", "cyan3","cyan")))(100)
heatmap_GO_mit_sig = heatmap.2(as.matrix(explc_mit), col = col0, Rowv = TRUE, Colv = TRUE, scale = "row",
                               dendrogram = "both",
                               trace = "none",
                               main = "GO Mitochondrial Membrane",
                               margin = c(5,15))
```

- In this heatmap, I've used a new color palette. Now blue is downregulated and orange is upregulated

- Now, search within rlog_BD_10 for all the sig DE genes that correspond to the oxidoreductase terms
```{r,eval=FALSE}
oxidoreductase_sig = iso2go %>%
  filter(str_detect(GO.terms, "GO:0004129|GO:0015002|GO:0016676|GO:0016675")) %>%
  left_join(rlog_BD_10) %>%
  left_join(gene) %>%
  mutate(gene_symbol = make.names(gene_symbol, unique = TRUE)) %>%
  column_to_rownames(var = "gene_symbol") %>%
  dplyr::select(-GO.terms, -description, -gene_ID) %>%
  drop_na() %>%
  dplyr::select(sort(current_vars()))
oxidoreductase_sig
```
- We have 2 genes here, plot the difference from the mean on a heatmap
```{r,eval=FALSE}
oxidoreductase_means_sig = apply(oxidoreductase_sig, 1, mean)
explc_oxr = oxidoreductase_sig-oxidoreductase_means_sig
head(explc_oxr)

heatmap_oxidoreductase_sig = heatmap.2(as.matrix(explc_oxr), col = col0, Rowv = TRUE, Colv = TRUE, scale = "row",
                                   dendrogram = "both",
                                   trace = "none",
                                   main = "GO Oxidoreductase",
                                   margin = c(5,15))
```

- For the final step, I'm going to make a heatmap of all the genes that are differentially regulated (alpha = 0.05 and alpha = 0.01 to account for the count differences) that will allow for further exploration

```{r,eval=FALSE}
BD_DE_05 = filter(BD_DE, pval.BD <= 0.05, preserve = TRUE)
head(BD_DE_05) 
rlog_BD_05 = BD_DE_05[,1:7] %>%
  rename(gene_ID = X)
head(rlog_BD_05)
nrow(rlog_BD_05)

BD_DE_01 = filter(BD_DE, pval.BD <= 0.01, preserve = TRUE)
head(BD_DE_01) 
rlog_BD_01 = BD_DE_01[,1:7] %>%
  rename(gene_ID = X)
head(rlog_BD_01)
nrow(rlog_BD_01)
```
- alpha of 0.05 yields 270 terms
- alpha of 0.01 yields 73 terms
- Let's also try padj alpha of 0.1:
```{r, eval=FALSE}
BD_DE_adj = filter(BD_DE, padj.BD <= 0.1, preserve = TRUE)
head(BD_DE_adj) 
rlog_BD_adj = BD_DE_adj[,1:7] %>%
  rename(gene_ID = X)
head(rlog_BD_adj)
nrow(rlog_BD_adj)
```
- padj yields 30 terms which is pretty manageable

```{r,eval=FALSE}
sigDEG_BD_adj = iso2go %>%
  left_join(rlog_BD_adj) %>%
  left_join(gene) %>%
  mutate(gene_symbol = make.names(gene_symbol, unique = TRUE)) %>%
  column_to_rownames(var = "gene_symbol") %>%
  dplyr::select(-GO.terms, -description, -gene_ID) %>%
  drop_na() %>%
  dplyr::select(sort(current_vars()))
head(sigDEG_BD_adj)
nrow(sigDEG_BD_adj)

sigDEG_BD_01 = iso2go %>%
  left_join(rlog_BD_01) %>%
  left_join(gene) %>%
  mutate(gene_symbol = make.names(gene_symbol, unique = TRUE)) %>%
  column_to_rownames(var = "gene_symbol") %>%
  dplyr::select(-GO.terms, -description, -gene_ID) %>%
  drop_na() %>%
  dplyr::select(sort(current_vars()))
head(sigDEG_BD_01)
nrow(sigDEG_BD_01)
```
- sigDEG_BD_adj are all my significant DEGs between B and D in the right format with padj of 0.1
- Only 22 out of the 30 DEGs had annotated GO terms
- sigDEG_BD_01 are all my significant DEGs between B and D in the right format with pval of 0.01
- Only 43 out of the 73 DEGs had annotated GO terms
- First making a heatmap of the raw values for the adj
```{r,eval=FALSE}
heatmap_sigDEG_adj = heatmap.2(as.matrix(sigDEG_BD_adj), col = col0, Rowv = TRUE, Colv = TRUE, scale = "row",
                           dendrogram = "both",
                           trace = "none",
                           main = "Significant DEG, padj < 0.1",
                           margin = c(5,15))
```
- A lot of the terms are un-annotated
- Now calculating the difference from the mean of the padj DEGs and making that a heatmap
```{r,eval=FALSE}
sigDEG_BD_means_adj = apply(sigDEG_BD_adj, 1, mean)
explc_sig_adj = sigDEG_BD_adj-sigDEG_BD_means_adj
heatmap_sigDEG_means_adj = heatmap.2(as.matrix(explc_sig_adj), col = col0, Rowv = TRUE, Colv = TRUE, scale = "row",
                           dendrogram = "both",
                           trace = "none",
                           main = "Significant DEG Mean, padj < 0.1",
                           margin = c(5,15))
```
- Do the same with the pval of 0.01
```{r, eval=FALSE}
heatmap_sigDEG_01 = heatmap.2(as.matrix(sigDEG_BD_01), col = col0, Rowv = TRUE, Colv = TRUE, scale = "row",
                           dendrogram = "both",
                           trace = "none",
                           main = "Significant DEG, pval < 0.01",
                           margin = c(5,15))

sigDEG_BD_means_01 = apply(sigDEG_BD_01, 1, mean)
explc_sig_01 = sigDEG_BD_01-sigDEG_BD_means_01
heatmap_sigDEG_means_01 = heatmap.2(as.matrix(explc_sig_01), col = col0, Rowv = TRUE, Colv = TRUE, scale = "row",
                           dendrogram = "both",
                           trace = "none",
                           main = "Significant DEG Mean, pval < 0.01",
                           margin = c(5,15))
```
- CYP3A28 is an Cytochrome P450, some genes for cytochrome P450 are NF-kB response genes; weakly downreg here
- As is pla2g4a (phospholipase)
- As is HSP110.1, not an NNF-kB response gene but is involved in thermal stress response
- As is the phosphodiesterase pde9a.2
- Cathepsin.1 is strongly upregulated in D; Cathepsin B and L are NF-kB response genes

- Make this list of genes and expression values into a csv file for future reference
- Also attach the jpg image of the heatmap so that all the gene symbols are visible
```{r, eval=FALSE}
write.csv(explc_sig_adj, "rare_0.1adjDEG_BD_genesymbols.csv", quote = F)
write.csv(explc_sig_01, "rare_0.01pvalDEG_BD_genesymbols.csv", quote = F)
knitr::opts_chunk$set(echo = TRUE)
knitr::include_graphics("Ofav Adj 0.1 Sig DEG Mean Heatmap.jpg")
```


## Conclusions 